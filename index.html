<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JARVIS Hologram Control v2</title>
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <!-- Three.js -->
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Courier New', Courier, monospace;
      color: #00e5ff;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 30px;
      box-sizing: border-box;
      z-index: 10;
    }

    .hud-segment {
      border-left: 2px solid rgba(0, 229, 255, 0.5);
      padding-left: 10px;
      margin-bottom: 10px;
    }

    .label {
      font-size: 10px;
      color: rgba(0, 229, 255, 0.5);
      margin-bottom: 2px;
    }

    .value {
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
    }

    #detection-alert {
      position: absolute;
      top: 50%;
      left: 30px;
      transform: translateY(-50%);
      display: none;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-50%) translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(-50%) translateX(0);
      }
    }

    #reticle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      border: 1px solid rgba(0, 229, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #reticle::before,
    #reticle::after {
      content: '';
      position: absolute;
      background: rgba(0, 229, 255, 0.5);
    }

    #reticle::before {
      width: 10px;
      height: 1px;
    }

    #reticle::after {
      width: 1px;
      height: 10px;
    }

    /* Hidden Video */
    #input_video {
      display: none;
    }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .scanlines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%,
          rgba(0, 0, 0, 0.2) 50%);
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 20;
    }
  </style>
</head>

<body>
  <div id="loading">
    <div style="font-size: 20px; margin-bottom: 10px;">INITIALIZING HUD SYSTEM...</div>
    <div style="width: 200px; height: 2px; background: rgba(0,229,255,0.2);">
      <div id="bar" style="width: 0%; height: 100%; background: #00e5ff; transition: width 0.5s;"></div>
    </div>
  </div>

  <video id="input_video"></video>

  <div id="ui-overlay">
    <div class="top-section">
      <div class="hud-segment">
        <div class="label">SİSTEM</div>
        <div class="value" id="status-val">SYNC_PENDING</div>
      </div>
      <div class="hud-segment">
        <div class="label">FPS</div>
        <div class="value" id="fps-val">00</div>
      </div>
    </div>

    <div id="detection-alert">
      <div style="background: rgba(0, 229, 255, 0.1); border: 1px solid #00e5ff; padding: 10px 20px;">
        <span style="color: #00e5ff; font-weight: bold;">HAND DETECTED</span>
        <div style="font-size: 8px; margin-top: 5px;">TRACKING ACTIVE // SECURE_LINK</div>
      </div>
    </div>

    <div class="bottom-section" style="display: flex; justify-content: space-between; align-items: flex-end;">
      <div class="hud-segment">
        <div class="label">COORDS</div>
        <div class="value" id="coord-val">X:0.0 Y:0.0</div>
      </div>
      <div class="hud-segment"
        style="text-align: right; border-left: none; border-right: 2px solid rgba(0, 229, 255, 0.5); padding-left: 0; padding-right: 10px;">
        <div class="label">GESTURE</div>
        <div class="value" id="gesture-val">IDLE</div>
      </div>
    </div>
  </div>

  <div id="reticle"></div>
  <div class="scanlines"></div>

  <script type="module">
    import * as THREE from 'three';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

    let scene, camera, renderer, composer, hologram;
    let videoElement, hands;
    let lastFrameTime = performance.now();

    const state = {
      rightHand: {
        active: false,
        targetRotation: new THREE.Euler(),
        pointingVector: new THREE.Vector2(),
        deadZone: 0.1,
        lerpFactor: 0.05
      },
      leftHand: {
        active: false,
        targetZoom: 5,
        lerpFactor: 0.1
      }
    };

    const hologramShader = {
      uniforms: {
        uTime: { value: 0 },
        uColor: { value: new THREE.Color(0x00e5ff) }
      },
      vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vPosition;
                uniform float uTime;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                varying vec3 vNormal;
                varying vec3 vPosition;
                uniform float uTime;
                uniform vec3 uColor;
                void main() {
                    float fresnel = pow(1.5 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                    float scanline = sin(vPosition.y * 80.0 + uTime * 6.0) * 0.1 + 0.9;
                    float flicker = (sin(uTime * 40.0) * 0.05 + 0.95);
                    gl_FragColor = vec4(uColor, (fresnel * 0.7 + 0.1) * scanline * flicker * 0.8);
                }
            `
    };

    async function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      const renderScene = new RenderPass(scene, camera);
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
      composer = new EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      createHologram();
      await setupMediaPipe();

      document.getElementById('loading').style.display = 'none';
      document.getElementById('status-val').innerText = 'READY';

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function createHologram() {
      const group = new THREE.Group();
      const geometry = new THREE.IcosahedronGeometry(1.5, 2);
      const material = new THREE.ShaderMaterial({
        uniforms: THREE.UniformsUtils.clone(hologramShader.uniforms),
        vertexShader: hologramShader.vertexShader,
        fragmentShader: hologramShader.fragmentShader,
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        wireframe: true
      });

      hologram = new THREE.Mesh(geometry, material);
      group.add(hologram);

      // Tech rings
      for (let i = 0; i < 2; i++) {
        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(2 + i * 0.5, 0.01, 16, 100),
          material.clone()
        );
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
      }

      scene.add(group);
      hologram = group;
    }

    async function setupMediaPipe() {
      videoElement = document.getElementById('input_video');
      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });

      hands.onResults(onResults);

      const cam = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 640, height: 480
      });
      cam.start();
    }

    function onResults(results) {
      state.rightHand.active = false;
      state.leftHand.active = false;
      document.getElementById('detection-alert').style.display = 'none';

      if (results.multiHandLandmarks) {
        if (results.multiHandLandmarks.length > 0) {
          document.getElementById('detection-alert').style.display = 'block';
        }

        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const lms = results.multiHandLandmarks[i];
          const label = results.multiHandedness[i].label; // Left/Right from camera view

          // Note: MediaPipe labels are mirrored by default if not flipped.
          // Usually 'Left' is user's Right hand if not flipped. Let's handle it.
          if (label === 'Left') { // USER'S RIGHT HAND (mirrored)
            handleRotation(lms);
          } else { // USER'S LEFT HAND
            handleZoom(lms);
          }
        }
      }
    }

    function handleRotation(lms) {
      // Index Pointing: Vector from MCP (5) to Tip (8)
      const mcp = lms[5];
      const tip = lms[8];

      // Normalized direction vector in 2D
      const dir = {
        x: (tip.x - mcp.x) * 10, // Scale for sensitivity
        y: (tip.y - mcp.y) * 10
      };

      // Dead Zone check
      if (Math.abs(dir.x) < state.rightHand.deadZone) dir.x = 0;
      if (Math.abs(dir.y) < state.rightHand.deadZone) dir.y = 0;

      state.rightHand.active = true;
      // Target Rotation based on vector direction
      // Sola işaret -> Y -, Sağa -> Y +
      // Yukarı -> X -, Aşağı -> X +
      state.rightHand.targetRotation.y = -dir.x * Math.PI * 0.5;
      state.rightHand.targetRotation.x = dir.y * Math.PI * 0.5;

      // Update UI
      document.getElementById('coord-val').innerText = `X:${dir.x.toFixed(1)} Y:${dir.y.toFixed(1)}`;
      document.getElementById('gesture-val').innerText = 'POINTING';

      // Reticle movement
      const reticle = document.getElementById('reticle');
      reticle.style.left = `${(1 - tip.x) * 100}%`;
      reticle.style.top = `${tip.y * 100}%`;
    }

    function handleZoom(lms) {
      // Pinch: Thumb Tip (4) to Index Tip (8)
      const d = Math.sqrt(Math.pow(lms[4].x - lms[8].x, 2) + Math.pow(lms[4].y - lms[8].y, 2));
      state.leftHand.active = true;
      state.leftHand.targetZoom = THREE.MathUtils.mapLinear(d, 0.05, 0.3, 3, 10);
      state.leftHand.targetZoom = THREE.MathUtils.clamp(state.leftHand.targetZoom, 2, 15);
      document.getElementById('gesture-val').innerText = 'PINCH_ZOOM';
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now() * 0.001;

      // FPS
      const now = performance.now();
      if (Math.random() > 0.9) document.getElementById('fps-val').innerText = Math.round(1000 / (now - lastFrameTime)).toString().padStart(2, '0');
      lastFrameTime = now;

      if (hologram) {
        hologram.traverse(c => {
          if (c.material && c.material.uniforms) c.material.uniforms.uTime.value = time;
        });

        // Smooth Rotation with Easing
        if (state.rightHand.active) {
          hologram.rotation.y += (state.rightHand.targetRotation.y - hologram.rotation.y) * state.rightHand.lerpFactor;
          hologram.rotation.x += (state.rightHand.targetRotation.x - hologram.rotation.x) * state.rightHand.lerpFactor;
        } else {
          hologram.rotation.y += 0.01; // Auto-spin
        }

        // Smooth Zoom
        if (state.leftHand.active) {
          camera.position.z += (state.leftHand.targetZoom - camera.position.z) * state.leftHand.lerpFactor;
        }
      }

      composer.render();
    }

    init();
  </script>
</body>

</html>